# Kruskal algorithm

[![CMake](https://github.com/Algorithms-and-Data-Structures-2021/semester-work-kruskal-11-006/actions/workflows/cmake.yml/badge.svg)](https://github.com/Algorithms-and-Data-Structures-2021/semester-work-kruskal-11-006/actions/workflows/cmake.yml)

Алгоритм Краскала предназначен для нахождения минимального остовного дерева, т.е. такого подграфа который бы имел столько же компонент связности, сколько и исходный, но не содержал петель и сумма весов всех его ребер была бы минимальной. Алгоритм впервые описан Джзефом Крускалом в 1956 году.
 
Далее представлены взвешенный связный неориентированный граф и его остов.
![Пример графа G](https://github.com/Algorithms-and-Data-Structures-2021/semester-work-kruskal-11-006/blob/main/screenshot/%D0%BF%D1%80%D0%B5%D0%B2%D1%8C%D1%8E.jpg) 
![Пример остовного дерева графа G](https://github.com/Algorithms-and-Data-Structures-2021/semester-work-kruskal-11-006/blob/main/screenshot/%D0%BE%D1%81%D1%82%D0%BE%D0%B2.jpg)

Алгоритм Краскала:

1. Сортируем ребра графа по возрастанию весов.
2. Ребро с наименьшим весом и добавляем его в остовное дерево. Если добавление ребра создало цикл, то отклоняем это ребро.
3. Добавлем ребра, пока все вершин не будут входить в итоговый остов.

Оценка сложности алгоритма:

- Сложность алгоритма `O(m*log(m))`, где m - ребра. 

Применение алгоритма:

1. Разработка сетей. 
2. Производство печатных плат. По аналогии с сетью: мы хотим соединить n контактов
проводами с минимальной суммарной стоимостью. 
3. Минимальное остовное дерево может использоваться для визуализации
многоаспектных, многомерных данных, например, для отображения их взаимосвязи 
4. Наука, и в частности биология, используют многомерные данные для группировки
объектов, растений, животных. Минимальное остовное дерево позволяет разбивать их
на взаимосвязанные классы, четко отслеживая близкие по строению и
характеристикам группы

## Команда "Bubble Quasar"


|    Фамилия Имя     |   Вклад (%)   |        Прозвище       |
| :---               |   ---:        |  ---:                 |
| Бровин Роман       |      34       |                       |
| Суреева Анна       |      33       |                       |
| Стяжкин Александр  |      33       |                       |

**Девиз команды**
> _Деревья любили мы недолго, теперь рубим их на остовы_

## Структура проекта

Проект состоит из следующих частей:

- [`src`](src)/[`include`](include) - реализация алгоритма (исходный код и заголовочные файлы для класса ребер, графа и самого алгоритма);
- [`benchmark`](benchmark) - контрольные тесты производительности алгоритма Краскала;
- [`examples`](examples) - примеры работы с алгоритмом;
- [`dataset`](dataset) - наборы данных для запуска контрольных тестов и их генерация;

Требования (Prerequisites)

_В этом разделе задаются основые требования к программному и аппаратному обеспечению для успешной работы с проектом._

Рекомендуемые требования:

1. С++ компилятор c поддержкой стандарта C++17 (например, _GNU GCC 8.1.x_ и выше).
2. Система автоматизации сборки _CMake_ (версия _3.12.x_ и выше).
3. Интерпретатор _Python_ (версия _3.7.x_ и выше).
4. Рекомендуемый объем оперативной памяти - не менее 4 ГБ.
5. Свободное дисковое пространство объемом ~ 3 ГБ (набор данных для контрольных тестов).

## Сборка и запуск

_Инструкция по сборке проекта, генерации тестовых данных, запуска контрольных тестов и примеров работы._

#### Сборка проекта (Windows)

Склонируйте проект к себе на устройство через [Git for Windows](https://gitforwindows.org/) (либо используйте
возможности IDE):

```shell
git clone https://github.com/Algorithms-and-Data-Structures-2021/semester-work-kruskal-11-006.git
```

Для ручной сборки проекта в терминале введите:

```shell
# переход в папку с проектом
cd C:\Users\username\asd-projects\semester-work-kruskal-11-006

# создание папки для файлов сборки (чтобы не засорять папку с проектом) 
mkdir -p build && cd build 

# сборка проекта
cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo && cmake --config RelWithDebInfo --build . 
```

#### Генерация тестовых данных

Формат хранения данных, выбранный для этого проекта, - .csv

Генерация тестового набора данных в
формате [comma-seperated values (CSV)](https://en.wikipedia.org/wiki/Comma-separated_values):

```shell
# переход в папку генерации набора данных
cd dataset

# generate_csv_dataset.py Отвечает за генерацию данных, запустив эту программу вы сгенерируете 10 наборов данных,
# в каждом из которых будет 10 .csv файлов с различным количеством элементов

# Чтобы запустить генерацию данных, нужно написать в терминале приведенную нижу команду(требуется питон интерпретатор)
python generate_csv_dataset.py

#После генерации данных 10 наборов появятся в папке data, оттуда можете скопировать их в другие папки.

# Папка data организавана следующим образом:

```shell
dataset/data/
   01/
      100.csv
      ...
      500000.csv
   02/ ...
   03/ ...
   ...
   10/ ...
```

По названию директории `/dataset/data/` можно понять, что здесь хранятся наборы данных для контрольных тестов поисполнению алгоритма Краскала. Названия файлов `100.csv`. `500000.csv` и т.д. хранят информацию о размере набора данных (т.е. количество элементов). 

#### Контрольные тесты (benchmarks)

_Опишите, как запустить контрольные тесты, что они из себя представляют, какие метрики замеряют (время работы,
потребление памяти и пр.)._

Для запуска контрольных тестов необходимо предварительно сгенерировать или скачать готовый набор тестовых данных. Учтите, что данные, которые вы получили в предыдущих тестах, будут стёрты. Результаты тестов будут находиться по пути semester-work-kruskal-11-006/benchmark/benchmark_algorithm_result.csv.

**Примечание**. Ссылка на архив с набором данных, который при необходимости можно скачать.(ссылка)

##### Список контрольных тестов

| Название                  | Описание                                | Метрики         |
| :---                      | ---                                     | :---            |
| `benchmark_Kruskal.cpp`   | алгоритм Краскала                       | _время_         |

##### Примеры запуска

_Для запуска просто нажмите run benchmark_Kruskal.cpp, при этом перед запуском не забудьте отчистить старые данные в benchmark_algorithm_result.csv_


## Источники
1. [Как работает алгоритм Краскала](https://evileg.com/uk/post/523/#header_%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_%D0%9A%D1%80%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D0%B0)
2. [Описание работв алгоритма Краскала](https://pykhtina.files.wordpress.com/2016/04/mapks_l30_lekcia.pdf)
3. [Wiki about Kruskal's algorithm](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%80%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D0%B0)
